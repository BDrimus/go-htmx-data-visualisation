{{define "svg_chart"}}
{{$width := 400.0}}
{{$height := 200.0}}
{{$tooltipWidth := 50.0}}
{{$tooltipHeight := 20.0}}
{{$spacing := div $width (float64 (len .Points))}}

<div class="bg-white shadow-lg rounded-lg p-6" aria-label="Time Series Chart">
    <h2 class="text-2xl font-bold mb-4">Time Series SVG Trend</h2>
    
    <svg viewBox="0 0 {{$width}} {{$height}}" 
     class="w-full relative" 
     id="chart" 
     data-tooltip-width="{{$tooltipWidth}}"
     role="img" 
     aria-labelledby="chart-title chart-desc">
        <title id="chart-title">Time Series Trend Chart</title>
        <desc id="chart-desc">A line chart showing time series data trends</desc>
        
        <!-- Add axis lines -->
        <line x1="0" y1="{{$height}}" x2="{{$width}}" y2="{{$height}}" 
            class="stroke-gray-300" stroke-width="1"/>
        <line x1="0" y1="0" x2="0" y2="{{$height}}" 
            class="stroke-gray-300" stroke-width="1"/>
            
        <line id="vertical-line" x1="0" y1="0" x2="0" y2="{{$height}}" 
            class="stroke-gray-300 opacity-0" stroke-width="1" 
            pointer-events="none"
        />
        
        <polyline
            points="
                {{range $index, $point := .Points}}
                    {{mul (float64 $index) $spacing}},{{sub $height (mul $point.Value (div $height $.MaxValue))}}
                {{end}}"
            fill="none"
            class="stroke-blue-500"
            stroke-width="2"
            vector-effect="non-scaling-stroke"
        />
        
        {{range $index, $point := .Points}}
            <g class="chart-point" data-x="{{mul (float64 $index) $spacing}}" data-value="{{$point.Value}}">
                <circle 
                    cx="{{mul (float64 $index) $spacing}}"
                    cy="{{sub $height (mul $point.Value (div $height $.MaxValue))}}"
                    r="4"
                    class="fill-blue-500 opacity-0 transition-opacity duration-200"
                />
                <g class="tooltip opacity-0 transition-opacity duration-200 pointer-events-none">
                    <rect
                        x="{{mul (float64 $index) $spacing}}"
                        y="{{sub (sub $height (mul $point.Value (div $height $.MaxValue))) 25}}"
                        width="{{$tooltipWidth}}"
                        height="{{$tooltipHeight}}"
                        rx="4"
                        class="fill-gray-800"
                    />
                    <text 
                        x="{{mul (float64 $index) $spacing}}"
                        y="{{sub (sub $height (mul $point.Value (div $height $.MaxValue))) 10}}"
                        text-anchor="middle"
                        class="text-sm fill-white"
                    >
                        {{printf "%.2f" $point.Value}}
                    </text>
                </g>
            </g>
        {{end}}
    </svg>
</div>

<script>
function initChart() {
    const chart = document.getElementById('chart');
    if (!chart) return;
    
    const verticalLine = document.getElementById('vertical-line'); // Vertical line for the SVG chart
    const tooltipWidth = parseInt(parseFloat(chart.dataset.tooltipWidth), 10); // Width of the tooltip
    const svgWidth = parseInt(chart.viewBox.baseVal.width, 10); // Width of the SVG element
    let debounceTimeout; // Timeout for debouncing mousemove events

    // Resize observer to update the chart scale
    const resizeObserver = new ResizeObserver(entries => {
        for (const entry of entries) {
            if (entry.target === chart) {
                updateChartScale();
            }
        }
    });

    resizeObserver.observe(chart);

    function updateChartScale() {
        const rect = chart.getBoundingClientRect();
        chart.style.height = `${rect.width * 0.5}px`;
    }

    // Convert mouse position to SVG scale
    function getScaledMousePosition(event, svg) {
        const rect = svg.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const scale = svgWidth / rect.width;
        return mouseX * scale;
    }

    function updateVerticalLine(x) {
        verticalLine.setAttribute('x1', x);
        verticalLine.setAttribute('x2', x);
        verticalLine.classList.remove('opacity-0');
    }

    function positionTooltip(pointX, tooltip) {
        const rect = tooltip.querySelector('rect');
        const text = tooltip.querySelector('text');
        
        if (pointX < tooltipWidth / 2) {
            rect.setAttribute('transform', 'translate(0,0)');
            text.setAttribute('x', pointX + tooltipWidth / 2);
        } else if (pointX > svgWidth - tooltipWidth) {
            rect.setAttribute('transform', `translate(-${tooltipWidth},0)`);
            text.setAttribute('x', pointX - tooltipWidth / 2);
        } else {
            rect.setAttribute('transform', `translate(-${tooltipWidth / 2},0)`);
            text.setAttribute('x', pointX);
        }
        
        const valueY = parseFloat(rect.getAttribute('y'));
        if (valueY < 0) {
            rect.setAttribute('y', '5');
            text.setAttribute('y', '20');
        }
    }

    function handleMouseMove(e) {
        if (debounceTimeout) clearTimeout(debounceTimeout);
        
        debounceTimeout = setTimeout(() => {
            const mouseX = getScaledMousePosition(e, this);
            updateVerticalLine(mouseX);
            
            const points = [...document.querySelectorAll('.chart-point')];
            const spacing = this.viewBox.baseVal.width / (points.length - 1);
            const threshold = spacing * 0.5;
            
            points.forEach(point => {
                const pointX = parseFloat(point.dataset.x);
                const tooltip = point.querySelector('.tooltip');
                const circle = point.querySelector('circle');
                
                if (Math.abs(pointX - mouseX) < threshold) {
                    tooltip.classList.remove('opacity-0');
                    circle.classList.remove('opacity-0');
                    positionTooltip(pointX, tooltip);
                } else {
                    tooltip.classList.add('opacity-0');
                    circle.classList.add('opacity-0');
                }
            });
        }, );
    }

    function handleMouseLeave() {
        if (debounceTimeout) clearTimeout(debounceTimeout);
        verticalLine.classList.add('opacity-0');
        document.querySelectorAll('.chart-point .tooltip, .chart-point circle').forEach(el => {
            el.classList.add('opacity-0');
        });
    }

    chart.addEventListener('mousemove', handleMouseMove);
    chart.addEventListener('mouseleave', handleMouseLeave);

    return () => {
        resizeObserver.disconnect();
        chart.removeEventListener('mousemove', handleMouseMove);
        chart.removeEventListener('mouseleave', handleMouseLeave);
    };
}

// Initialize on page load and HTMX swaps
document.addEventListener('htmx:afterSwap', () => {
    initChart();
});

// Initial load
initChart();
</script>
{{end}}